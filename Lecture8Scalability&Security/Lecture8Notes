To host your web applications you can deploy your code to a server whcih is just a dedicated piece of hardware that is listening and responding for requests.
There are 2 types of servers cloud which is managed by an external company like amazon (aws) or on premise which are physical devices which can be accessed easily and are kept in the companies building on say a server rack.
Benchmarking is a method to figure out what is the maximum load or amount of users a server can handle, some tools you can use to test this is apache.
There are 2 methods or ways to scale your program as your userbase grows. Vertical Scaling is simply getting swapping out a smaller server for a new bigger one which can handle more users. The other method is Horizontal Scaling, in which you get a second server of the same capacity to ouble the maximum load your service can handle, however this requires another pieace of hardware known as a load balancer which recieves requests before the servers and then directs the request to whichever server is running at the most optimal level at the time.
The three main load balancing methods are random choice which is the simplest but least optimal for user satisfaction, Round Robin which just rotates between the servers so user 1 goes to server 1 user 2 to server 2 and so on. However this method also has trade offs as if some requests take longer than others it could lead to a server crash if too many requests are made at once. THe third option is what i listed on the previous line which is fewest connections however this generally requires a slightly harder calculation for the load balancer and thus is slightly more expensive.
One inherent problem with all the methods mentioned above is that they dont have any way to use or store prior sessions meaning user settings and whether the user is logged in or not wont be stored. Some session-aware load balancing methods are sticky sessions which maes the load balancer always send you to the same server, sessions in database which is a database where all details about users are stored which can be accessed and transferred to all servers and client-side sessions which is just storing a cookie on local storage which can be accessed by all the servers when the web application is loaded.
One way to scale the number of servers on the cloud is by using auto-scaling which will automatically add or remove servers depending on the amount of traffic coming to the application at that time. THis is avery cost effective solution but not the most efficient as it takes time for the service to add or remove a server.
This system however does prevent against the whole web application failong if one server fails, this is known as a single point of failure.
One way to test if a server has failed or crashed is too periodically maybe every 30 seconds tell the load balancer to send a simple ping request and if the server doesnt respond indicating that it has crashed, stop sending request and traffic to that server.
To prevent a single point of failure on the load balancer it is also a reasonable idea to have a second load balancer that just pings the original load balancer unless the original one goes down in which case the back up will take its place and the entire application won't crash.
When hosting a web application yoiu also have to think about a database which will also be stored externally using MySQL or MongoDB. 
It is ideal to simplify databases by partioning them either by vertical partioning which is where you have a main table that draws from a second table using id's thus having less columns in each table or horizontal partioning which is where you split your main table into 2 different tables with the same number of columns but different data so that at any given time your application would only need to search through one such as splitting a flights database into a domestic and international flights database.
However this is where another issue could arise as there is only one database which is another possible single point of failure and this is where database replication comes in. There are two types of database replication, single-primary replication and multi-primary replication.
Single primary replication is where you have many databases but with only one database being able to both write and read while the others are read only. This is one solution however this is another possible source of a single point of failure error as if this database goes down then you wont be able to write to the database. Another issue is the possibility of the single write and read server being overloaded.
Multi primary replication is where you have multiple databases and all of them can write and read, this prevents overload and point of failure errors but it has its own drawbacks such as update errors and conflict errors if multiple users change the same section at the same time and errors while informing the other duplicate databases of the changes.
Caching is a cost-effective and efficient principle which is the process of storing data to easier access data and reduce load on servers by making less requests. 
One way of using the caching principle you can use client side caching which is the browser storing a copy of elements of the websites, you can do this by using the Cache-Control: max-age= command to not make a new request and instead to use a cached version of the resource if enough time as set has not passed.
Another way is by using etags which is a string of data stored and shared between your browser and the server which dictates if the etags on the server and browser are different then make a new request and update the etag on the users browser because files have changes otherwise just load the cached version because nothing has changed.
You can also have server side caching which is another pieace in your system which the server can interact with along with the database.
By default django has abuilt in cache framework which allows you to have per-view caching which will reuse a certain view for a set amount of time if you expect it wont change in the period, a low level cache API and template fragment caching which is similar to per-view caching but you can specify only parts of the webpage/display and not the whole display.
SECURITY Section BEGINS:
One security risk with git is that your repository is open source and can be accesed by many people and shared. This is useful for finding bugs but those bugs can also be used for exploitation of the website and you users can go back through the history of the project to look for old versions of the program with possibly exposed credentials which is why it is important to wipe saved versions with sensitive informating rather than just making a new commit as you can still see project history and versio control.
One security issue with html is phishing which is where a link says it will take you somewhere but rather takes you to completely different place. This is unlikely to come in your own web application but is something look out for more generally while on the internet or checking emails.
Frameworks like django work on the idea of requests and responses, however to do this securely you need to have you data be encrypted os no random server can just read what information was sent or recieved by you, this is where https a secure version of http comes in. There are multiple methods of encryption however the most common modern method is public key cryptography in which the server send sme there public key which can  be seen by everyone i use that to encrypt my plain text into cyphertext, i then send the cyphertext to the server which then uses it's own private key whcih should and was never shared on the internet publically to decrypt and access the original text I sent.
With SQL there is also the concern of SQL injection, which is a specifically phgrased input to bypass a certain system or authentication method.
With certain programs you can also inadvertantly give up information even without trying to. For example on a forgot your password page, hackers could spam emails in the field to check who has an account and who doesnt based on the latency of the servers response or if the program just say user not found or email sent.
Some security measures you can take when dealing with API'S are rate limiting which is to prevent against a denial of service attack and route authentication using an API key to check only authorised users can access certain data from the API.
One vulnerability in javacript is XSS or cross site scripting which is where someone can add js code and have it run on my web application without it being written by me.
Another vulnerability when request are being used is csrf (cross site request forgery) where a fake request is made for malicious reasons, however this can be avoided by adding csrf tokens and asking for validation.
